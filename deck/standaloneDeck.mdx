import { CodeSurfer } from "code-surfer";

import { myTheme } from "./theme";

import { TitleSlide } from './TitleSlide';
import { LinkSlide } from './LinkSlide';
import { Audio } from "./Audio";

export const theme = myTheme;

<Head>
  <title>Making Minimal Techno with WebAssembly And a C Compiler</title>
</Head>

<TitleSlide />

---

<CodeSurfer >

```js
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });
```

```js
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);
```

</CodeSurfer>

---

---

<CodeSurfer>

```js
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    return true;
  }
}
```

```js 3:6
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

</CodeSurfer>

---

---

<CodeSurfer>

```c
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 3
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 5
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 5:9
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 5:11
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

</CodeSurfer>

---

---

<CodeSurfer>

```bash
# Compile C to WASM with Emscripten / Clang
emcc \
  --no-entry \
  -O3 \
  -s WASM=1 \
  -s EXPORTED_FUNCTIONS=_makeSomeTechno \
  -o techno.wasm \
  techno.c
```

</CodeSurfer>

---

---

<CodeSurfer>

```js
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);
```

```js 9:11
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);

// Load WASM code
let wasmCode = await fetch("techno.wasm")
  .then((r) => r.arrayBuffer());
// Send it to the Audio Worklet
worklet.port.postMessage({ wasmCode });
```

```js 12:13
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);

// Load WASM code
let wasmCode = await fetch("techno.wasm")
  .then((r) => r.arrayBuffer());
// Send it to the Audio Worklet
worklet.port.postMessage({ wasmCode });
```


</CodeSurfer>

---

---

<CodeSurfer>

```js
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 3:8
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 7:10
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 11:12
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 13:14
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 21:22
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

```js 23:24
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

```js 24[23:58]
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

```js 24[5:22,59:59]
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

</CodeSurfer>

---

---

<Audio
  versions={{
    10: {step: 0, reset: 0},
    11: {step: 0, reset: 0},
    12: {step: 0, reset: 0},
    13: {step: 0, reset: 0},
    14: {step: 0, reset: 0},
    15: {step: 0, reset: 0},
    16: {step: 0, reset: 0},
    17: {step: 1, reset: 0},
    18: {step: 1, reset: 0},
    19: {step: 2, reset: 0},
    20: {step: 3, reset: 0},
    21: {step: 4, reset: 0},
    22: {step: 5, reset: 0},
    23: {step: 6, reset: 0},
    24: {step: 7, reset: 0},
    25: {step: 7, reset: 0},
    26: {step: 8, reset: 0},
    27: {step: 9, reset: 0},
    28: {step: 10, reset: 0},
    29: {step: 10, reset: 0},
    30: {step: 11, reset: 0},
    31: {step: 11, reset: 0},
    32: {step: 12, reset: 0},
    33: {step: 12, reset: 0},
    34: {step: 12, reset: 0},
    35: {step: 12, reset: 0},
    36: {step: 13, reset: 0},
    37: {step: 14, reset: 0},
    38: {step: 15, reset: 0},
    39: {step: 16, reset: 0},
    40: {step: 17, reset: 0},
    41: {step: 17, reset: 0},
    42: {step: 18, reset: 0},
    43: {step: 19, reset: 0},
    44: {step: 19, reset: 0},
    45: {step: 19, reset: 0},
    46: {step: 20, reset: 0},
    47: {step: 20, reset: 0},
    48: {step: 20, reset: 0},
    49: {step: 20, reset: 0},
    50: {step: 20, reset: 0},
    51: {step: 20, reset: 0},
    52: {step: 20, reset: 0},
    53: {step: 21, reset: 0},
    54: {step: 21, reset: 0},
    55: {step: 22, reset: 0},
    56: {step: 22, reset: 0},
  }}
/>

<CodeSurfer >

```c
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 4:6

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 8:10

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
}

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 8:10

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
}

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 8:11

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
}

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 8:12

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 17,22:23

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 7,25

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 26

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 28

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```


```c 18,24

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time

    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 24:25

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM

    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 24:26

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:17

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp) {
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:17

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp) {
  float env = 1.0f - t; // Decay from 1 to 0
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp) {
  float env = 1.0f - t; // Decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20,37

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp) {
  float env = 1.0f - t; // Decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20,37

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickFreq = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```


```c 34

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickFreq = 50.0f + envelope(tBeatFrac, 200.0f, 3.0f); // Freq decay 250->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```



```c 34

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 40:46

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass); // Saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```


```c 44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 34:45

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 3.0f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```


```c 47:53

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```


```c 33:34

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 53

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 22:29

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 62:64

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = sinf(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 61

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = sinf(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 61

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = saw6f(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  return sinf(phase)
    ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = saw6f(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:22

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = saw6f(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```


```c 16:23

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = saw6f(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:24

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = saw6f(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:25

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = saw6f(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:26

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = saw6f(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```


```c 71,73

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase = phasor(chordPhase, chordFreq);
    float chord = saw6f(chordPhase * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 72:77

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 72:79

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 71:82

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 55

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 74

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```


```c 43:44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // 48000 = 1 second of samples

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 43:46

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // 48000 = 1 second of samples
float processDelay(float input, float delayTime) {
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45:47

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // 48000 = 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45:48

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // 48000 = 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45:49

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // 48000 = 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45:50

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // 48000 = 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 95

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // 48000 = 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```


```c 46:48

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float feedback, float delayTime) {
  // Write current input retaining some of the previous output as feedback
  delayLine[delayIndex] = input + delayLine[delayIndex] * feedback;
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 96

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float feedback, float delayTime) {
  // Write current input retaining some of the previous output as feedback
  delayLine[delayIndex] = input + delayLine[delayIndex] * feedback;
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.5f, 0.375f) * 0.4f; // Dotted 8th feedback delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

// Additive sawtooth wave
float saw6f(float phase) {
  // Add harmonics
  return sinf(phase)
    + sinf(phase * 2.0f) * 0.5f
    + sinf(phase * 3.0f) * 0.33f
    + sinf(phase * 4.0f) * 0.25f
    + sinf(phase * 5.0f) * 0.2f
    + sinf(phase * 6.0f) * 0.16f
      ;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

// Rhythm pattern in sixteenth notes
// 1 = play chord, 0 = don't play chord
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[(int)SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float feedback, float delayTime) {
  // Write current input retaining some of the previous output as feedback
  delayLine[delayIndex] = input + delayLine[delayIndex] * feedback;
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    int bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time within 16th (0-1)

    // Kick
    float kickFreq = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Freq decay 950->50Hz
    kickPhase = phasor(kickPhase, kickFreq);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassFreq = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassFreq);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordFreq = bassFreq * 4.0f; // 200Hz, 2 octaves above bass
    if (bar % 4 == 2 || bar % 4 == 3) chordFreq *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordFreq);
    chordPhase2 = phasor(chordPhase2, chordFreq * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordFreq * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    int chordPatternIndex = (int)tSixteenths % 16; // 0-15
    char chordHit = chordPattern[chordPatternIndex]; // 0 or 1 if chord should play
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.5f, 0.375f) * 0.4f; // Dotted 8th feedback delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

</CodeSurfer>

---

<LinkSlide />