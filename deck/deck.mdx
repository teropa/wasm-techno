import { CodeSurfer } from "code-surfer";

import { myTheme } from "./theme";

import { Audio } from "./Audio";

export const theme = myTheme;

<Head>
  <title>Making Minimal Techno with WebAssembly And a C Compiler</title>
</Head>

# Hello

---

<CodeSurfer >

```js
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });
```

```js
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);
```

</CodeSurfer>

---

---

<CodeSurfer>

```js
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    return true;
  }
}
```

```js 3:6
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

</CodeSurfer>

---

---

<CodeSurfer>

```c
// Audio Processing code in C

// Array of samples
static float outputBuffer[128];

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 3:4
// Audio Processing code in C

// Array of samples
static float outputBuffer[128];

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 6
// Audio Processing code in C

// Array of samples
static float outputBuffer[128];

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 6:10
// Audio Processing code in C

// Array of samples
static float outputBuffer[128];

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 6:12
// Audio Processing code in C

// Array of samples
static float outputBuffer[128];

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

</CodeSurfer>

---

---

<CodeSurfer>

```bash
# Compile C to WASM with Emscripten / Clang
emcc \
  --no-entry \
  -O3 \
  -s WASM=1 \
  -s EXPORTED_FUNCTIONS=_makeSomeTechno \
  -o techno.wasm \
  techno.c
```

</CodeSurfer>

---

---

<CodeSurfer>

```js
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);
```

```js 9:11
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);

// Load WASM code
let wasmCode = await fetch("techno.wasm")
  .then((r) => r.arrayBuffer());
// Send it to the Audio Worklet
worklet.port.postMessage({ wasmCode });
```

```js 12:13
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);

// Load WASM code
let wasmCode = await fetch("techno.wasm")
  .then((r) => r.arrayBuffer());
// Send it to the Audio Worklet
worklet.port.postMessage({ wasmCode });
```


</CodeSurfer>

---

---

<CodeSurfer>

```js
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 3:8
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 7:10
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 11:12
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 13:14
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 21:22
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

```js 23:24
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

```js 24[23:58]
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

```js 24[5:22,59:59]
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

</CodeSurfer>

---

---

<Audio
  versions={{
    9: 0,
    13: 1,
    15: 2,
    17: 3,
    19: 4,
    21: 5,
    23: 6,
    25: 7,
    27: 8,
    29: 9,
    31: 10,
    34: 11,
    37: 12,
    41: 13,
    42: 14,
    43: 15,
    44: 16,
    45: 17,
    47: 18,
    49: 19,
    52: 20,
    60: 21,
    63: 22,
  }}
/>

<CodeSurfer >

```c 2:4

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 6:7

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 8

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 9

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 6:11

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13,17:18

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 19

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 20

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 22

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13,18

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 18:20

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13:15,29

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp) {
  return (1.0 - t) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13:15,29

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp) {
  return (1.0 - t) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13:15,29

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13:15,29

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 200.0f, 3.0f); // Shape the pitch
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 200.0f, 3.0f); // Shape the pitch
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 32:36,38[27:33]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 32:36,38[27:33]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 36

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass); // Saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 36

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass); // Saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 36

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 36

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 37

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 3.0f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 37

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 3.0f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 37

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 37

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 39:43,45[34:41]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 39:43,45[34:41]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 25:26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 45

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 45

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 17:22

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 52,53[48:58]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 52,53[48:58]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 51

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 13:15

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  return sinf(phase);
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 14:16

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 14:16

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 14:17

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 14:18

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 14:19

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 14:20

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 60:65

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 60:65

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 60:67

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 60:67

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 43

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 62

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 62

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 34:36

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 37

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 38

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 39

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 40

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 41

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 82

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 82

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 37:39

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float feedback, float delayTime) {
  // Write current input retaining some of the previous output as feedback
  delayLine[delayIndex] = input + delayLine[delayIndex] * feedback;
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 83

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float feedback, float delayTime) {
  // Write current input retaining some of the previous output as feedback
  delayLine[delayIndex] = input + delayLine[delayIndex] * feedback;
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.5f, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 83

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float feedback, float delayTime) {
  // Write current input retaining some of the previous output as feedback
  delayLine[delayIndex] = input + delayLine[delayIndex] * feedback;
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulated phase
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.5f, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

</CodeSurfer>

---

## The End
