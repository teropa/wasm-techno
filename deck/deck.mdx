import { CodeSurfer } from "code-surfer";

import { myTheme } from "./theme";

import { Audio } from "./Audio";

export const theme = myTheme;

<Head>
  <title>Making Minimal Techno with WebAssembly And a C Compiler</title>
</Head>

# Hello

---

<Audio
  versions={{
    9: "step1Sine",
    13: "step2LinearEnv",
    15: "step3ExponentialEnv",
    17: "step4KickPitchEnv1",
    19: "step5KickPitchEnv2",
    21: "step6BassSine",
    23: "step7BassSaturation1",
    25: "step8BassSaturation2",
    27: "step9BassSidechain1",
    29: "step10BassSidechain2",
    31: "step11ChordsSine",
    34: "step12ChordsBeats",
    37: "step13ChordsPattern",
  }}
/>

<CodeSurfer >

```c 2:4

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 6:7

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 8

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 9

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 6:11

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13,17:18

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 19

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 20

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 22

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13,18

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 18:20

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13:15,29

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp) {
  return (1.0 - t) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13:15,29

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp) {
  return (1.0 - t) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13:15,29

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 13:15,29

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 200.0f, 3.0f); // Shape the pitch
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 200.0f, 3.0f); // Shape the pitch
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  return outputBuffer;
}

```

```c 32:36,38[27:33]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 32:36,38[27:33]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 36

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass); // Saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 36

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass); // Saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 36

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 36

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 37

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 3.0)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 37

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 3.0)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 37

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 37

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  return outputBuffer;
}

```

```c 39:43,45[34:41]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4;
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1, 3.0);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 39:43,45[34:41]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4;
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1, 3.0);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 25:26

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0;
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths);

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4;
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1, 3.0);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 45

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0;
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths);

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4;
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1, 3.0);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 45

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0;
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths);

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4;
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1, 3.0);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 17:22

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0;
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths);

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4;
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1, 3.0);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 52,53[48:58]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0;
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths);

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4;
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1, 3.0) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

```c 52,53[48:58]

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE

// Define phasor between 0 and 1 at a given frequency
float phasor(float phase, float freq) {
  phase += SAMPLE_DUR * freq; // Increment at every sample
  phase -= trunc(phase);      // Keep between 0-1
  return phase;
}

float envelope(float t, float amp, float exp) {
  return powf(1.0 - t, exp) * amp; // Decay from amp to 0 over time
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulated phase

float* makeSomeTechno() {
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time in beat (0-1)
    float tSixteenths = tBeats * 4.0;
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths);

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // More!
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4;
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1, 3.0) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  return outputBuffer;
}

```

</CodeSurfer>

---

## The End
