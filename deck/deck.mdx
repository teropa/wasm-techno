import { CodeSurfer } from "code-surfer";

import { myTheme } from "./theme";

import { TitleSlide } from './TitleSlide';
import { Audio } from "./Audio";

export const theme = myTheme;

<Head>
  <title>Making Minimal Techno with WebAssembly And a C Compiler</title>
</Head>

<TitleSlide />

---

<CodeSurfer >

```js
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });
```

```js
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);
```

</CodeSurfer>

---

---

<CodeSurfer>

```js
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    return true;
  }
}
```

```js 3:6
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

</CodeSurfer>

---

---

<CodeSurfer>

```c
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 3
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 5
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 5:9
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 5:11
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

</CodeSurfer>

---

---

<CodeSurfer>

```bash
# Compile C to WASM with Emscripten / Clang
emcc \
  --no-entry \
  -O3 \
  -s WASM=1 \
  -s EXPORTED_FUNCTIONS=_makeSomeTechno \
  -o techno.wasm \
  techno.c
```

</CodeSurfer>

---

---

<CodeSurfer>

```js
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);
```

```js 9:11
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);

// Load WASM code
let wasmCode = await fetch("techno.wasm")
  .then((r) => r.arrayBuffer());
// Send it to the Audio Worklet
worklet.port.postMessage({ wasmCode });
```

```js 12:13
// Web Audio Context
let ctx = new AudioContext({ sampleRate: 48000 });

// Audio Worklet
await ctx.audioWorklet.addModule("TechnoProcessor.js");
let worklet = new AudioWorkletNode(ctx, "techno-processor");
worklet.connect(ctx.destination);

// Load WASM code
let wasmCode = await fetch("techno.wasm")
  .then((r) => r.arrayBuffer());
// Send it to the Audio Worklet
worklet.port.postMessage({ wasmCode });
```


</CodeSurfer>

---

---

<CodeSurfer>

```js
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 3:8
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 7:10
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 11:12
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 13:14
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    return true;
  }
}
```

```js 21:22
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

```js 23:24
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

```js 24[23:58]
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

```js 24[5:22,59:59]
// Audio Worklet Processor on Audio Thread
class TechnoProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Receive WASM code
    this.port.onmessage = async ({ data: { wasmCode } }) => {
      // Instantiate WASM module
      let {
        instance: { exports },
      } = await WebAssembly.instantiate(wasmCode);
      // Grab its exported API
      this.wasm = exports;
      // Grab its memory
      this.mem = this.wasm.memory.buffer;
      this.wasm._initialize();
    };
  }
  process(inputs, outputs) {
    // Process 48000 samples per second, 128 at a time
    if (!this.wasm) return true;
    // Call the C function and get the memory pointer
    let ptr = this.wasm.makeSomeTechno();
    // Copy the processed audio from WASM memory to audio output
    outputs[0][0].set(new Float32Array(this.mem, ptr, 128));
  }
}
```

</CodeSurfer>

---

---

<Audio
  versions={{
    10: 0,
    19: 1,
    22: 2,
    24: 3,
    26: 4,
    29: 5,
    32: 6,
    34: 7,
    36: 8,
    39: 9,
    41: 10,
    44: 11,
    47: 12,
    51: 13,
    52: 14,
    53: 15,
    54: 16,
    55: 17,
    57: 18,
    60: 19,
    62: 20,
    70: 21,
    73: 22,
  }}
/>

<CodeSurfer >

```c
// Audio Processing code in C

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}
```

```c 4:6

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 8:10

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
}

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 8:10

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
}

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 8:11

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
}

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 8:12

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 17,22:23

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 7,25

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 26

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = 0.0f;
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 28

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 18,24

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 24:25

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 24:26

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= 0.15f; // Make it less loud

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:17

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp) {
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:17

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp) {
  float env = 1.0f - t; // Decay from 1 to 0
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp) {
  float env = 1.0f - t; // Decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20,37

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp) {
  float env = 1.0f - t; // Decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20,37

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp) {
  float env = 1.0f - t; // Decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20,37

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:20,37

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 200.0f; // Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 34

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 200.0f, 3.0f); // Pitch decay 250->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 34

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 200.0f, 3.0f); // Pitch decay 250->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 34

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 34

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 34

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    outputBuffer[i] = kick; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 40:46

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 40:46

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 40:46

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass); // Saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass); // Saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= 0.2f; // Amplitude

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 3.0f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 3.0f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    outputBuffer[i] = kick + bass; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 47:51,53[34:41]

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 47:51,53[34:41]

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 33:34

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tBeatFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 53

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 53

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 22:27

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f);

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 60,61[52:62]

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 60,61[48:58]

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = sinf(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 59

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 16:18

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  return sinf(phase);
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 17:19

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 17:19

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 17:20

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 17:21

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 17:22

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 17:23

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, chordPhase = 0.0f; // Accumulate phase over time

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase = phasor(chordPhase, chordPitch);
    float chord = saw6f(chordPhase * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 68:73

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 68:73

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 68:75

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 68:75

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 51

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 70

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 70

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 39:41

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 42

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 43

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 45

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 46

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 90

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 90

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float delayTime) {
  delayLine[delayIndex] = input; // Write current input
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1f, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 42:44

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}
const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float feedback, float delayTime) {
  // Write current input retaining some of the previous output as feedback
  delayLine[delayIndex] = input + delayLine[delayIndex] * feedback;
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 91

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float feedback, float delayTime) {
  // Write current input retaining some of the previous output as feedback
  delayLine[delayIndex] = input + delayLine[delayIndex] * feedback;
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.5f, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

```c 91

// Audio Processing code in C

// Determine duration of one sample
#define SAMPLERATE 48000.0f
#define SAMPLE_DUR 1.0f / SAMPLERATE // ~0.02ms
#define TWO_PI 6.2831853f

// Define a phasor that runs from 0 to 1 at a given frequency
float phasor(float phase, float freq) {
  phase += freq * SAMPLE_DUR; // Increment by one sample
  phase -= trunc(phase);      // When it reaches 1 go back to 0
  return phase;
}

float saw6f(float phase) {
  // Add harmonics
  return sinf(phase) +
    sinf(phase * 2.0f) * 0.5f +
    sinf(phase * 3.0f) * 0.33f +
    sinf(phase * 4.0f) * 0.25f +
    sinf(phase * 5.0f) * 0.2f +
    sinf(phase * 6.0f) * 0.16f;
}

float envelope(float t, float amp, float exp) {
  float env = powf(1.0 - t, exp); // Exponentially decay from 1 to 0
  env *= amp; // Decay from amp to 0
  return env;
}

const char chordPattern[16] = {
  0, 1, 0, 0,
  0, 0, 1, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
};

// Ring buffer delay line
float delayLine[SAMPLERATE] = {0}; // Store max 1 second of samples
int delayIndex = 0;
float processDelay(float input, float feedback, float delayTime) {
  // Write current input retaining some of the previous output as feedback
  delayLine[delayIndex] = input + delayLine[delayIndex] * feedback;
  delayIndex++; // Move to next sample
  delayIndex %= (int)(delayTime * SAMPLERATE); // Wrap if exceeding delay time
  return delayLine[delayIndex]; // Read delayed output
}

static float outputBuffer[128]; // Array of samples

unsigned long long tSamples = 0; // Accumulated samples
float kickPhase = 0.0f, bassPhase = 0.0f, // Accumulate phase over time
      chordPhase1 = 0.0f, chordPhase2 = 0.0f, chordPhase3 = 0.0f;

float* makeSomeTechno() {
  // Process 128 samples into the array
  for (int i = 0; i < 128; i++) {
    float tSeconds = tSamples++ * SAMPLE_DUR; // Current time
    float tBeats = tSeconds * 2.0f; // Current beat @ 120 BPM
    float tBeatFrac = tBeats - trunc(tBeats); // Time within beat (0-1)
    float bar = tBeats / 4.0f; // Current bar (in 4/4 time)
    float tSixteenths = tBeats * 4.0; // Current 16th note
    float tSixteenthFrac = tSixteenths - trunc(tSixteenths); // Time in 16th (0-1)

    // Kick
    float kickPitch = 50.0f + envelope(tBeatFrac, 900.0f, 50.0f); // Pitch decay 950->50Hz
    kickPhase = phasor(kickPhase, kickPitch);
    float kick = sin(kickPhase * TWO_PI); // Sine wave
    kick *= envelope(tBeatFrac, 0.15f, 3.0f); // Shape the amplitude

    // Bass
    float bassPitch = 50.0f; // Hz
    bassPhase = phasor(bassPhase, bassPitch);
    float bass = sinf(bassPhase * TWO_PI); // Sine wave
    bass = tanh(bass * 1.5f); // More saturation
    bass *= (0.2f - envelope(tBeatFrac, 0.2f, 0.5f)); // "Sidechaining"

    // Chords
    float chordRootPitch = bassPitch * 4.0f; // 2 octaves above bass
    if (fmodf(bar, 4.0f) >= 2.0f) chordRootPitch *= 2.0f/3.0f; // Perfect 5th down
    chordPhase1 = phasor(chordPhase1, chordRootPitch);
    chordPhase2 = phasor(chordPhase2, chordRootPitch * 3.0f/2.0f); // Perfect 5th
    chordPhase3 = phasor(chordPhase3, chordRootPitch * 6.0f/5.0f); // Minor 3rd
    float chord =
      saw6f(chordPhase1 * TWO_PI) +
      saw6f(chordPhase2 * TWO_PI) +
      saw6f(chordPhase3 * TWO_PI);
    char chordHit = chordPattern[(int)tSixteenths % 16];
    chord *= envelope(tSixteenthFrac, 0.1, 3.0f) * chordHit;
    chord = chord + processDelay(chord, 0.5f, 0.375f) * 0.4f; // Dotted 8th delay

    outputBuffer[i] = kick + bass + chord; // Output
  }
  // Return pointer to the array
  return outputBuffer;
}

```

</CodeSurfer>

---

## The End
